<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Swinging cats with monocles</title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/isaias.css" id="theme">

	<link rel="stylesheet" href="lib/css/darcula.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
	<link rel="stylesheet" href="css/overrides.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1>
					Swinging cats with monocles
				</h1>
				<p>Isaias Bartelborth</p>
				<p>Github:
					<a href="https://github.com/isaias-b">https://github.com/isaias-b</a>
				</p>
			</section>
			<section>
				<h2>
					Agenda
				</h2>
				<ul>
					<li>Motivation: Why to use lenses or optics?</li>
					<li>Optics: What does Monocle offer us?</li>
					<li>Integration: How to use it with cats?</li>
					<li>Example: Small Swing application.</li>
				</ul>
			</section>
			<section>
				<section>
					<h3>Why to use lenses or optics?</h3>
					<p>
						Lenses facilitate drill down into product shaped types.
						In essence a lens only does function composition.
					</p>
					<p>
						Challenge: Can we do that manually?
					</p>
					<p>
						Let's see!
					</p>
				</section>
				<section>
					<h3>Classical Example</h3>
					<pre><code class="scala trim strip-margin" data-line-numbers="6,11">
							|case class Street(name: String, number: Int)
							|case class Address(city: String, street: Street)
							|case class Person(fullName: String, address: Address)
							|
							|val person: Person = Person("Max Muster",
							|  Address("Cologne", Street("neumarkt", 123))
							|
							|person.copy(
							|  address = person.address.copy(
							|    street = person.address.street.copy(
							|      name = person.address.street.name.capitalize
							|    )
							|  )
							|)
						</code></pre>
					<p>
						Copy functions are tedious to write.
						Start extracting those first then reuse em.
					</p>
				</section>
				<section>
					<h3>Extract copy methods</h3>
					<p>
						Copy methods can be created for each field on the associated companion object.
					</p>
					<pre><code class="scala trim">
							|object Person {
							|  val setAddress: Person => Address => Person =
							|    p => x => p.copy(address = x)
							|}
							|object Address {
							|  val setStreet: Address => Street => Address =
							|    p => x => p.copy(street = x)
							|}
							|object Street {
							|  val setName: Street => String => Street =
							|    p => x => p.copy(name = x)
							|}
						</code></pre>
				</section>
				<section>
					<h3>Use setters instead (Before)</h3>
					<pre><code class="scala trim">
							|person.copy(
							|  address = person.address.copy(
							|    street = person.address.street.copy(
							|      name = person.address.street.name.capitalize
							|    )
							|  )
							|)
						</code></pre>
				</section>
				<section>
					<h3>Use setters instead (After)</h3>
					<pre><code class="scala trim">
							|Person.setAddress(person)(
							|  Address.setStreet(person.address)(
							|    Street.setName(person.address.street)(
							|      person.address.street.name.capitalize
							|    )
							|  )
							|)
						</code></pre>
					<p>No copy methods left. \o/</p>
					<p>Now remove the function cascade.</p>
				</section>
				<section>
					<h3>Unfold function cascade</h3>
					<pre><code class="scala trim">
							|val n = person.address.street.name.capitalize
							|val s = Street.setName(person.address.street)(n)
							|val a = Address.setStreet(person.address)(s)
							|Person.setAddress(person)(a)
						</code></pre>
					<p>Cleaner, but still a lot of repetition.</p>
				</section>
				<section>
					<h3>Extract variables</h3>
					<pre><code class="scala trim" data-line-numbers="3-5">
							|val a1 = person.address
							|val s1 = a1.street
							|val n1 = s1.name                // s1: Street comes in
							|val n2 = n1.capitalize          // capitalize: String => String
							|val s2 = Street.setName(s1)(n2) // s2: Street comes out
							|val a2 = Address.setStreet(a1)(s2)
							|Person.setAddress(person)(a2)
						</code></pre>
					<p>
						Here is an opportunity to extract a function that operates on a street's name.
					</p>
				</section>
				<section>
					<h3>Extract <code>modifyStreet</code></h3>
					<pre><code class="scala trim">
							|def modifyStreet(s: Street)(f: String => String): Street = {
							|  val n1 = s.name          // getName: Street => String
							|  val n2 = f(n1)
							|  Street.setName(s)(n2)    // setName: Street => String => Street
							|}
						</code></pre>
					<p>
						Cool, but let's return a function instead and try to pass in the getter and setter for the street's name.
					</p>
				</section>
				<section>
					<h3>Abstract <code>modifyStreet</code></h3>
					<pre><code class="scala trim">
							|def modifyStreet1(
							|    get: Street => String,
							|    set: Street => String => Street
							|  )(
							|    f: String => String
							|  ): Street => Street = s => {
							|    val n1 = get(s)
							|    val n2 = f(n1)
							|    set(s)(n2)
							|  }
						</code></pre>
					<p>
						Now this function is very generic. It is independent of the actual types. Let's parameterize it.
					</p>
				</section>
				<section>
					<h3>Parameterize into <code>modify</code></h3>
					<pre><code class="scala trim">
							|def modify[S, A](
							|    get: S => A,
							|    set: S => A => S
							|  )(f: A => A): S => S = s => {
							|  val a1 = get(s)
							|  val a2 = f(a1)
							|  set(s)(a2)
							|}
						</code></pre>
					<p>
						In essence this function allows us to lift any other function with the shape of <code>A => A</code>
						into a function of same shape but different type <code>S => S</code>. That is useful!
					</p>
				</section>
				<section>
					<h3>Envision a target</h3>
					<pre><code class="scala trim">
							|val modName:    String  => String  = _.capitalize
							|val modStreet:  Street  => Street  = ???
							|val modAddress: Address => Address = ???
							|val modPerson:  Person  => Person  = ???
							|modPerson(person)
						</code></pre>
				</section>
				<section>
					<h3>Use <code>modify</code></h3>
					<pre><code class="scala trim">
							|import Street.setName // and others...
							|
							|val a1 = person.address
							|val s1 = a1.street
							|val s2 = modify[Street, String](_.name, setName)(_.capitalize)(s1)
							|val a2 = Address.setStreet(a1)(s2)
							|Person.setAddress(person)(a2)
						</code></pre>
					<p>
						Nice. Ok let's move on!
					</p>
				</section>
				<section>
					<h3>Refactor into function values</h3>
					<pre><code class="scala trim">
							|val a1 = person.address
							|val s1 = a1.street
							|val modName:    String => String = _.capitalize
							|val modStreet:  Street => Street =
							|  modify[Street, String](_.name, Street.setName)(modName)
							|val a2 = Address.setStreet(a1)(modStreet(s1))
							|Person.setAddress(person)(a2)
						</code></pre>
					<p>
						Now treat modification of address and person the same way.
					</p>
				</section>
				<section>
					<h3>Refactor modification of address and person</h3>
					<pre><code class="scala trim">
							|val modName:    String  => String  = _.capitalize
							|val modStreet:  Street  => Street  =
							|  modify[Street, String](_.name, Street.setName)(modName)
							|val modAddress: Address => Address =
							|  a => Address.setStreet(a)(modStreet(a.street))
							|val modPerson:  Person  => Person  =
							|  p => Person.setAddress(p)(modAddress(p.address))
							|modPerson(person)
						</code></pre>
					<p>
						Pattern of <code>modify</code> starts to emerge, so let's reuse it again.
					</p>
				</section>
				<section>
					<h3>Refactor modification of address and person</h3>
					<pre><code class="scala trim">
							|val modName:    String  => String  = _.capitalize
							|val modStreet:  Street  => Street  =
							|  modify[Street, String](_.name, setName)(modName)
							|val modAddress: Address => Address =
							|  modify[Address, Street](_.street, setStreet)(modStreet)
							|val modPerson:  Person  => Person  =
							|  modify[Person, Address](_.address, setAddress)(modAddress)
							|modPerson(person)
						</code></pre>
					<p>
						This works, but unfortunately is still very tedious to write and read.
					</p>
				</section>
				<section>
					<h3>Ideal solution</h3>
					<p>
						Ideally we would be able to modify a nested element without having to chain functions ourselves.
					</p>
					<pre><code class="scala trim">
							|modify[Person, String](???, ???)(_.capitalize)(person)
						</code></pre>
					<p>
						For this we need composition of getters and setters.
					</p>
				</section>
				<section>
					<h3>Compose getters and setters</h3>
					<p>
						For getters this is just plain function composition.
					</p>
					<pre><code class="scala trim">
							|def composeGetters[S,A,B](
							|    getA: S => A,
							|    getB: A => B
							|  ): S => B =
							|    getB.compose(getA)
						</code></pre>
					<p>
						Let's try to do this the same way for setters...
					</p>
				</section>
				<section>
					<h3>Attempt to compose setters</h3>
					<p>
						We need to aggregate all inputs to produce valid results.
					</p>
					<pre><code class="scala trim">
							|def composeSettersX[S,A,B](
							|    setA: S => A => S,
							|    setB: A => B => A
							|  ): S => B => S = s => b => {
							|    ???
							|  }
						</code></pre>
					<p>
						However, there is no way where can we put our given b into.
						Only setB takes a b, but setB requires an A.
						Unfortunately there is no way to get an A.
					</p>
					<p>
						==> impossible to implement
					</p>
				</section>
				<section>
					<h3>Compose setters</h3>
					<p>
						Any ideas??
					</p>
					<pre><code class="scala trim">
							|def composeSetters[S,A,B](
							|    setA: S => A => S,
							|    setB: A => B => A,
							|    getA: S => A
							|  ): S => B => S = s => b => {
							|    val a1 = getA(s)
							|    val a2 = setB(a1)(b)
							|    setA(s)(a2)
							|  }
						</code></pre>
					<p>
						Setter composition requires a getter üò≤.
					</p>
				</section>
				<section>
					<h3>Use composition of setters and getters</h3>
					<p>

					</p>
					<pre><code class="scala trim">
							|val setNameA = composeSetters[Address, Street, String](
							|  Address.setStreet, Street.setName, _.street
							|)
							|val setNameP = composeSetters[Person, Address, String](
							|  Person.setAddress, setNameA, _.address
							|)
							|val getNameA = composeGetters[Address, Street, String](
							|  _.street, _.name
							|)
							|val getNameP = composeGetters[Person, Address, String](
							|  _.address, getNameA
							|)
							|modify[Person, String](getNameP, setNameP)(_.capitalize)(person)
						</code></pre>
					<p>
						SUCCESS, but still very clumpsy and even repetitive.
					</p>
				</section>
				<section>
					<h3>Container for getter and setter</h3>
					<pre><code class="scala trim">
							|case class Lens[S, A](get: S => A, set: S => A => S) {
							|  def modify(f: A => A): S => S = s => {
							|    val a1 = get(s)
							|    val a2 = f(a1)
							|    set(s)(a2)
							|  }
							|  def compose[B](lb: Lens[A, B]): Lens[S, B] = Lens[S, B](
							|    s =>      lb.get(get(s)),            // getter composition
							|    s => b => set(s)(lb.set(get(s))(b))  // setter composition
							|  )
							|}
						</code></pre>
					<p>
						For now our Lens is just a container for a set and a get operation.
					</p>
				</section>
				<section>
					<h3>Use <code>Lens</code></h3>
					<pre><code class="scala trim">
							|Lens[Person, Address](_.address, Person.setAddress)
							|  .compose(Lens[Address, Street](_.street, Address.setStreet))
							|  .compose(Lens[Street, String](_.name, Street.setName))
							|  .modify(_.capitalize)(person)
						</code></pre>
					<p>
						This seems to be like the abstraction we were looking for.
					</p>
				</section>
			</section>
			<section>
				<section>
					<h2>What does Monocle offer us?</h2>
					<ul>
						<li>Different optics: Lens, Prism, Iso, Optional...</li>
						<li>Mature optics model</li>
						<li>Correct implementation with good performance</li>
						<li>Law based testing for custom optics</li>
						<li>Various composition patterns</li>
						<li>Many ways to derive optics</li>
						<li>Integrates with: cats</li>
						<li>Reduce boilerplate code from O(n¬≤) to O(n)</li>
					</ul>
				</section>
				<section>
					<h3>Use generated <code>Lens</code></h3>
					<pre><code class="scala trim">
							|import monocle.macros.{GenLens, Lenses}
							|import monocle.macros.syntax.lens._
							|
							|@Lenses case class Street(name: String, number: Int)
							|@Lenses case class Address(city: String, street: Street)
							|@Lenses case class Person(fullName: String, address: Address)
							|
							|val person: Person = Person("Max Mustermann",
							|  Address("Cologne", Street("neumarkt", 123))
							|)
							|
							|Person.address
							|  .composeLens(Address.street)
							|  .composeLens(Street.name)
							|  .modify(_.capitalize)(person)
						</code></pre>
					<p>
						WOW, pretty neat!
					</p>
				</section>
				<section>
					<h3>Ways to generate <code>Lens</code></h3>
					<p>Generate <code>Lens</code> instances by using the:</p>
					<ul>
						<li><code>@Lenses</code> macro annotation</li>
						<li><code>GenLens</code> with a projection to an inner field</li>
						<li>‚ö†Ô∏è Constructor with <code>get</code> and <code>set</code> functions</li>
					</ul>
					<p>The last option provides the least safety. Verify Validity!</p>
				</section>
				<section>
					<h3><code>Lens</code> Laws</h3>
					<pre><code class="scala trim">
							|// monocle.law.discipline.LensTests
							|// monocle.law.LensLaws
							|new SimpleRuleSet("Lens",
							|  "set what you get"                -> forAll(???),
							|  // lens.set(lens.get(s))(s) <==> s
							|  "get what you set"                -> forAll(???),
							|  // lens.get(lens.set(a)(s)) <==> a
							|  "set idempotent"                  -> forAll(???),
							|  // lens.set(a)(lens.set(a)(s)) <==> lens.set(a)(s)
							|  "modify id = id"                  -> forAll(???),
							|  "compose modify"                  -> forAll(???),
							|  "consistent set with modify"      -> forAll(???),
							|  "consistent modify with modifyId" -> forAll(???),
							|  "consistent get with modifyId"    -> forAll(???)
							|)
						</code></pre>
				</section>
				<section>
					<h3>Cheat Sheet: <code>Lens</code></h3>
					<pre><code class="scala trim">
							|case class Lens[S, A](
							|  get: S => A,         // focus always succeeds, but is lossy
							|  set: A => S => S     // that's why unfocus requires extra S
							|)
						</code></pre>
					<ul>
						<li>Focuses on one field inside product type</li>
						<li>Must obey <code>Lens</code> Laws to be valid</li>
						<li>Replaces copy methods</li>
					</ul>
				</section>
				<section>
					<h3>Optics overview</h3>
					<img class="no-decorations filter-invert" width="80%" src="img/optics-class-diag2.svg" />
				</section>
				<section>
					<h3>Cheat Sheet: <code>Prism</code></h3>
					<pre><code class="scala trim">
							|case class Prism[S, A](
							|  getOption: S => Option[A], // focus may fail, but is not lossy
							|  reverseGet: A => S         // unfocus never requires extra S
							|)
						</code></pre>
					<ul>
						<li>Focuses on one member of a sum type</li>
						<li>Must obey <code>Prism</code> Laws to be valid</li>
						<li>Replaces match case expressions</li>
						<li>Alternative to typesafe downcasts</li>
						<li>Relates to apply and unapply</li>
					</ul>
				</section>
				<section>
					<h3>Ways to generate <code>Prism</code></h3>
					<ul>
						<li>Predefined instances at <code>monocle.std.</code>:</li>
						<ul>
							<li><code>option.some</code></li>
							<li><code>either.stdRight</code></li>
							<li><code>either.stdLeft</code></li>
						</ul>
						<li><code>GenPrism</code> with a base- to subtype relation</li>
						<li>‚ö†Ô∏è Constructor with <code>getOption</code> and <code>reverseGet</code> functions</li>
					</ul>
					<p>The last option provides the least safety. Verify validity!</p>
				</section>
				<section>
					<h3>Given a non-trivial<code>Prism</code></h3>
					<pre><code class="scala trim">
							|object MyOptics {
							|  def list2mapGetter[A]: Getter[List[A], Map[Int, A]] =
							|    Getter(l => l.zipWithIndex.map(_.swap).toMap)
							|  def map2ListGetter[A]: Getter[Map[Int, A], List[A]] =
							|    Getter(m => m.toList.sortBy(_._1).map(_._2))
							|
							|  def map2listPrism[A]: Prism[Map[Int, A], List[A]] =
							|    Prism[Map[Int, A], List[A]]{ m =>
							|      if (m.isEmpty) Some(List.empty)
							|      else if (m.size == (m.keys.max + 1) && m.keys.min == 0)
							|        Some(map2ListGetter[A].get(m))
							|      else
							|        None
							|    }(l => list2mapGetter[A].get(l))
							|}
						</code></pre>
				</section>
				<section>
					<h3>Setup test harness</h3>
					<pre><code class="bash trim">
							|import cats.kernel.Eq
							|import monocle.function.GenericOptics
							|import monocle.law.discipline.PrismTests
							|import monocle.std.StdInstances
							|import monocle.syntax.Syntaxes
							|import org.scalatest.{FunSuite, Matchers}
							|import org.typelevel.discipline.scalatest.Discipline
						</code></pre>
				</section>
				<section>
					<h3>Test your <code>Prism</code></h3>
					<pre><code class="scala trim">
							|class MySpec extends FunSuite with Discipline with Matchers
							|    with StdInstances with GenericOptics with Syntaxes {
							|  implicit val eqListInt: Eq[List[Int]]    = Eq.fromUniversalEquals
							|  implicit val eqMapInt: Eq[Map[Int, Int]] = Eq.fromUniversalEquals
							|  checkAll("map2listPrism", PrismTests(MyOptics.map2listPrism[Int]))
							|}
						</code></pre>
				</section>
				<section>
					<h3><code>Prism</code> Laws</h3>
					<pre><code class="scala trim">
							|$ sbt test
							|...
						    |[info] MySpec:
						    |[info] - map2listPrism.Prism.compose modify
						    |[info] - map2listPrism.Prism.consistent getOption with modifyId
						    |[info] - map2listPrism.Prism.consistent modify with modifyId
						    |[info] - map2listPrism.Prism.consistent set with modify
						    |[info] - map2listPrism.Prism.modify id = id
						    |[info] - map2listPrism.Prism.partial round trip one way
						    |[info] - map2listPrism.Prism.round trip other way
							|[info] NextSpec:
							|...
						</code></pre>
				</section>
				<section>
					<h3><code>Prism</code> Laws</h3>
					<pre><code class="scala trim">
							|// monocle.law.discipline.PrismTests
							|// monocle.law.PrismLaws
							|new SimpleRuleSet("Prism",
							|  "partial round trip one way"          -> forAll(???),
							|  // prism.getOrModify(s).fold(identity, prism.reverseGet) <==> s
							|  "round trip other way"                -> forAll(???),
							|  // prism.getOption(prism.reverseGet(a)) <==> Some(a)
							|  "modify id = id"                      -> forAll(???),
							|  // prism.modify(identity)(s) <==> s
							|  "compose modify"                      -> forAll(???),
							|  "consistent set with modify"          -> forAll(???),
							|  "consistent modify with modifyId"     -> forAll(???),
							|  "consistent getOption with modifyId"  -> forAll(???)
							|)
						</code></pre>
				</section>
				<section>
					<h3>Composition Basics</h3>
					<ul>
						<li>Two optics of same kind mostly produce a new composed optic of this exact same kind.</li>
						<li>Two optics of different kind will only produce a composed optic of weaker kind, if possible.</li>
						<ul>
							<li>If both optics share a weaker supertype, then the composed optic will be of kind of the closest
								supertype.</li>
							<li>If both optics don't share a weaker supertype, then the composed optic doesn't exist in general.</li>
						</ul>
					</ul>
				</section>
				<section>
					<h3>Weaker top & stronger bot</h3>
					<img class="no-decorations filter-invert" width="80%" src="img/optics-class-diag2.svg" />
				</section>
				<section>
					<h3>Operators or functions</h3>
					<p>
						Most of the time neither, set nor get is used directly.
						Instead one of the more high level operators is being used when using optics.
					</p>
					<pre><code class="scala trim">
							|trait Modify[S, A] {
							|  def modify(f: A => A): S => S
							|}
							|trait ModifyF[S, A] {
							|  def modifyF[F[_]: Applicative](f: A => F[A]): S => F[S]
							|}
						</code></pre>
				</section>

				<section>
					<h3><code>modify</code></h3>
					<img class="no-decorations filter-invert" width="80%" src="img/optics-class-diag2-modify.svg" />
				</section>
				<section>
					<h3><code>modifyF</code></h3>
					<img class="no-decorations filter-invert" width="80%" src="img/optics-class-diag2-modifyF.svg" />
				</section>
				<section>
					<img class="no-decorations filter-invert" src="img/lens-vs-prism2.svg" />
				</section>
				<section>
					<img class="no-decorations filter-invert" src="img/overview-diag3.svg" />
				</section>
			</section>
			<section>
				<section>
					<h2>Moncle with cats</h2>
				</section>
				<section>
					<h3>Use cases for cats</h3>
					<ul>
						<li>Use <code>Traverse</code> to turn things inside out.</li>
						<li>Monocle is built with cats.</li>
						<li><code>modifyF</code> requires an <code>Applicative</code>.</li>
						<li><code>IO</code> is actually an <code>Applicative</code>.</li>
					</ul>
				</section>
				<section>
					<h3>Use cases for cats-effect</h3>
					<ul>
						<li>Encapsulate side effects in <code>IO</code>.</li>
						<li>Switch between thread pools with <code>ContextSwitch</code>.</li>
						<li>Timing can be done with <code>Timer</code>.</li>
						<li>Start off new asynchronous operations as <code>Fiber</code>s.</li>
						<li>Share state concurrently with <code>MVar</code> and <code>Ref</code>.</li>
						<li>Reliably harvest <code>Resource</code>s that are safe to use.</li>
					</ul>
				</section>
				<section>
					<h3><code>IO</code> and <code>modifyF</code></h3>
				</section>
				<section data-transition="fade">
					<h3><code>IO</code> and <code>modifyF</code></h3>
					<pre><code class="scala trim">
							|// def modifyF[F[_]: Applicative](f: A => F[A]): S => F[S]
							|import cats.effect._
							|import monocle.Prism
							|import scala.concurrent.duration._
							|import cats.effect.IOApp
							|
							|trait App extends IOApp {
							|  val fetch: Int => IO[Int] = input =>
							|    IO.sleep(2.seconds).map(_ => input + 1)
							|  val prism: Prism[Option[Int], Int] = monocle.std.option.some
							|  val computeNextOpt  /* ???????????????????????? */ =
							|    prism.modifyF(fetch)
							|}
						</code></pre>
				</section>
				<section data-transition="fade">
					<h3><code>IO</code> and <code>modifyF</code></h3>
					<pre><code class="scala trim">
							|// def modifyF[F[_]: Applicative](f: A => F[A]): S => F[S]
							|import cats.effect._
							|import monocle.Prism
							|import scala.concurrent.duration._
							|import cats.effect.IOApp
							|
							|trait App extends IOApp {
							|  val fetch: Int => IO[Int] = input =>
							|    IO.sleep(2.seconds).map(_ => input + 1)
							|  val prism: Prism[Option[Int], Int] = monocle.std.option.some
							|  val computeNextOpt: Option[Int] => IO[Option[Int]] =
							|    prism.modifyF(fetch)
							|}
						</code></pre>
				</section>
				<section>
					<h3>Traverse over <code>Option</code> with <code>IO</code></h3>
				</section>
				<section data-transition="fade">
					<h3>Traverse over <code>Option</code> with <code>IO</code></h3>
					<pre><code class="scala trim">
							|//no optics, just cats
							|import cats.effect._
							|import cats.syntax.traverse._
							|import cats.instances.option._
							|import scala.concurrent.duration._
							|import cats.effect.IOApp
							|
							|trait App extends IOApp {
							|  val fetch: Int => IO[Long] =
							|    input => IO.sleep(2.seconds).map(_ => input + 1)
							|  val optId: Option[Int]      = Some(123)
							|  val optIo: Option[IO[Long]] = optId.map(fetch)
							|  val ioOpt  /* ?????????? */ = optId.traverse(fetch)
							|}
						</code></pre>
				</section>
				<section data-transition="fade">
					<h3>Traverse over <code>Option</code> with <code>IO</code></h3>
					<pre><code class="scala trim">
							|//no optics, just cats
							|import cats.effect._
							|import cats.syntax.traverse._
							|import cats.instances.option._
							|import scala.concurrent.duration._
							|import cats.effect.IOApp
							|
							|trait App extends IOApp {
							|  val fetch: Int => IO[Long] =
							|    input => IO.sleep(2.seconds).map(_ => input + 1)
							|  val optId: Option[Int]      = Some(123)
							|  val optIo: Option[IO[Long]] = optId.map(fetch)
							|  val ioOpt: IO[Option[Long]] = optId.traverse(fetch)
							|}
						</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Resources & References</h2>
					<ul>
						<li><a href="https://julien-truffaut.github.io/Monocle/learning_resources.html">Monocle</a> Learning
							Resources.</li>
						<li><a href="https://www.scala-exercises.org/monocle/iso">Monocle</a> Scala exercises.</li>
						<li><a href="https://gitter.im/julien-truffaut/Monocle">Monocle</a> Gitter channel.</li>
						<li><a href="https://typelevel.org/cats/">Cats</a> FP key concepts.</li>
						<li><a href="https://typelevel.org/cats-effect/datatypes/">Cats-Effect</a> IO Monad.</li>
						<li><a href="https://github.com/kirill-grouchnikov/radiance">Radiance</a> Substance Look & Feel.</li>
						<li><a href="https://fazecast.github.io/jSerialComm/">JSerialComm</a> Portable serial communication.</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Demo</h2>
					<img class="no-decorations" src="img/swinging-cats-with-monocles.png" />
					<p>Source:
						<a href="https://github.com/isaias-b/serial-monitor/tree/DEMO-2019-06-18">
							https://github.com/isaias-b/serial-monitor/tree/DEMO-2019-06-18
						</a>
					</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Conclusion</h2>
					<p>Just a few key takeaways:</p>
					<ul>
						<li>Avoid <code>get/set/copy</code> methods.</li>
						<li>Prefer <code>modify</code> and <code>modifyF</code>.</li>
						<li>Refactor existing projects or start a new one ;)</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Thank You!</h2>
					<p>Slides:
						<a href="https://github.com/isaias-b/monocle-talk">
							https://github.com/isaias-b/monocle-talk
						</a>
					</p>
				</section>
			</section>
		</div>
	</div>

	<script src="js/reveal.js"></script>
	<script>
		function forEach(a, f) {
			var index = 0;
			for (index = 0; index < a.length; ++index) {
				f(a[index]);
			}
		}
		var regex = /[\t ]*\|/gi;
		forEach(document.getElementsByClassName("trim"), function (node) {
			console.log(node.textContent);
			node.textContent = node.textContent.trim().replace(regex, "");
		});
	</script>
	<script src="js/config.js"></script>
</body>

</html>